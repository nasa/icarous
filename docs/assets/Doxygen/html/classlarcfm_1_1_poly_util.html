<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICAROUS: larcfm::PolyUtil Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ICAROUS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelarcfm.html">larcfm</a></li><li class="navelem"><a class="el" href="classlarcfm_1_1_poly_util.html">PolyUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classlarcfm_1_1_poly_util-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">larcfm::PolyUtil Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util_1_1_s_i_comparator.html">SIComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa3ae40f18d2f619236c80735b0b94394"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#aa3ae40f18d2f619236c80735b0b94394">convexHull</a> (const std::vector&lt; <a class="el" href="classlarcfm_1_1_position.html">Position</a> &gt; &amp;plist, double bottom, double top)</td></tr>
<tr class="separator:aa3ae40f18d2f619236c80735b0b94394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a2d02489bb935e8b9dac524c2a36e7"><td class="memItemLeft" align="right" valign="top"><a id="a89a2d02489bb935e8b9dac524c2a36e7" name="a89a2d02489bb935e8b9dac524c2a36e7"></a>
static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><b>convexHull</b> (const <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;p)</td></tr>
<tr class="separator:a89a2d02489bb935e8b9dac524c2a36e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0169237cf6978d94f4db14123fd5982a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#a0169237cf6978d94f4db14123fd5982a">convexHull</a> (const std::vector&lt; <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &gt; &amp;p)</td></tr>
<tr class="separator:a0169237cf6978d94f4db14123fd5982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6609fd85de708619ef331228acec0433"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#a6609fd85de708619ef331228acec0433">convexHull</a> (const <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;p, double buffer)</td></tr>
<tr class="separator:a6609fd85de708619ef331228acec0433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a474b60f7ca36b6882c22200d44a25"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#a07a474b60f7ca36b6882c22200d44a25">pushOut</a> (<a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;poly, const <a class="el" href="classlarcfm_1_1_position.html">Position</a> &amp;p, double buffer)</td></tr>
<tr class="separator:a07a474b60f7ca36b6882c22200d44a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dee67c1a2e51c9eb5bf1a5079c8956f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#a8dee67c1a2e51c9eb5bf1a5079c8956f">pushOut</a> (<a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;poly, int i, double buffer)</td></tr>
<tr class="separator:a8dee67c1a2e51c9eb5bf1a5079c8956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbaca9d3532a92f52b8069db1a598f4"><td class="memItemLeft" align="right" valign="top"><a id="a9cbaca9d3532a92f52b8069db1a598f4" name="a9cbaca9d3532a92f52b8069db1a598f4"></a>
static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><b>simplify2</b> (<a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;p, double buffer)</td></tr>
<tr class="separator:a9cbaca9d3532a92f52b8069db1a598f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a34367cdc8627d13052a283364b379"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#ac6a34367cdc8627d13052a283364b379">simplify</a> (<a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;p, double buffer)</td></tr>
<tr class="separator:ac6a34367cdc8627d13052a283364b379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8253b7a153f55b9a3b51c133f8aa7ee3"><td class="memItemLeft" align="right" valign="top"><a id="a8253b7a153f55b9a3b51c133f8aa7ee3" name="a8253b7a153f55b9a3b51c133f8aa7ee3"></a>
static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><b>simplify</b> (<a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;p)</td></tr>
<tr class="separator:a8253b7a153f55b9a3b51c133f8aa7ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4e1f201be308652ffe954645bb1297"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#aaa4e1f201be308652ffe954645bb1297">simplifyToSize</a> (<a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;p, int num)</td></tr>
<tr class="separator:aaa4e1f201be308652ffe954645bb1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9b5c8f173b120d665078e9a31aaf27"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#aee9b5c8f173b120d665078e9a31aaf27">stretchOverTime</a> (const <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;sp, const <a class="el" href="classlarcfm_1_1_velocity.html">Velocity</a> &amp;v, double timeBefore, double timeAfter)</td></tr>
<tr class="separator:aee9b5c8f173b120d665078e9a31aaf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c3baa88aaa538b89c056786ec50fee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#a19c3baa88aaa538b89c056786ec50fee">stretchOverTime</a> (const <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &amp;pbase, double timeBefore, double timeAfter)</td></tr>
<tr class="separator:a19c3baa88aaa538b89c056786ec50fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ceba2a7329fa0b7c17ae586ed3b1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#ac26ceba2a7329fa0b7c17ae586ed3b1e">bufferedConvexHull</a> (<a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;p, double hbuff, double vbuff)</td></tr>
<tr class="separator:ac26ceba2a7329fa0b7c17ae586ed3b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad0a34d7ac94b33c79c46a4b42de7bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#afad0a34d7ac94b33c79c46a4b42de7bc">bufferedConvexHull</a> (const <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &amp;pbase, double hbuff, double vbuff)</td></tr>
<tr class="separator:afad0a34d7ac94b33c79c46a4b42de7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f9d1971914118c41af52351eefebc8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#a83f9d1971914118c41af52351eefebc8">intersectsPolygon2D</a> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;p, <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &amp;pp, double B, double T, double incr)</td></tr>
<tr class="separator:a83f9d1971914118c41af52351eefebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae669470dd3d47eb9425eaa4f9d4a0292"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_plan.html">Plan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#ae669470dd3d47eb9425eaa4f9d4a0292">reducePlanAgainstPolys</a> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;plan, double gs, std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;paths, double incr, bool leadInsPresent, const std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;containment)</td></tr>
<tr class="separator:ae669470dd3d47eb9425eaa4f9d4a0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93591f730a0f9a6a2fd2d9112a77288e"><td class="memItemLeft" align="right" valign="top"><a id="a93591f730a0f9a6a2fd2d9112a77288e" name="a93591f730a0f9a6a2fd2d9112a77288e"></a>
static <a class="el" href="classlarcfm_1_1_plan.html">Plan</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reducePlanAgainstPolys</b> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;pln, double gs, std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;paths, double incr, bool leadInsPresent)</td></tr>
<tr class="separator:a93591f730a0f9a6a2fd2d9112a77288e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17854767b6e91ef047361c3dc09b1534"><td class="memItemLeft" align="right" valign="top"><a id="a17854767b6e91ef047361c3dc09b1534" name="a17854767b6e91ef047361c3dc09b1534"></a>
static std::pair&lt; double, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>isPlanInConflictWx</b> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;plan, std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;paths, double start, double end, double incr)</td></tr>
<tr class="separator:a17854767b6e91ef047361c3dc09b1534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400389fb30f8cde1f1eda4425f514f10"><td class="memItemLeft" align="right" valign="top"><a id="a400389fb30f8cde1f1eda4425f514f10" name="a400389fb30f8cde1f1eda4425f514f10"></a>
static std::pair&lt; double, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>isPlanInConflictWx</b> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;plan, std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;paths, double incr)</td></tr>
<tr class="separator:a400389fb30f8cde1f1eda4425f514f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0b118c8dc8c2704ea1bf6b9e4f87b2"><td class="memItemLeft" align="right" valign="top"><a id="a5a0b118c8dc8c2704ea1bf6b9e4f87b2" name="a5a0b118c8dc8c2704ea1bf6b9e4f87b2"></a>
static std::pair&lt; double, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>isPlanInConflictWx</b> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;plan, std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;paths, double incr, double fromTime)</td></tr>
<tr class="separator:a5a0b118c8dc8c2704ea1bf6b9e4f87b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa11804b95bebc46758be968f9c1cd92"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#afa11804b95bebc46758be968f9c1cd92">isPlanContained</a> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;plan, const std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;paths, double B, double T, double incr)</td></tr>
<tr class="separator:afa11804b95bebc46758be968f9c1cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcf515d409d1048d1a9440725bf5af6"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_poly_util.html#aabcf515d409d1048d1a9440725bf5af6">calculateWxExitTime</a> (const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;plan, std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;paths, double incr, double entryTime)</td></tr>
<tr class="separator:aabcf515d409d1048d1a9440725bf5af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afad0a34d7ac94b33c79c46a4b42de7bc" name="afad0a34d7ac94b33c79c46a4b42de7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad0a34d7ac94b33c79c46a4b42de7bc">&#9670;&nbsp;</a></span>bufferedConvexHull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> larcfm::PolyUtil::bufferedConvexHull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &amp;&#160;</td>
          <td class="paramname"><em>pbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vbuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a path where polygons are replaced by convex hulls that have been expanded by hbuff and vbuff. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbase</td><td>base polygon path </td></tr>
    <tr><td class="paramname">hbuff</td><td>size of horizontal buffer (approx) </td></tr>
    <tr><td class="paramname">vbuff</td><td>size of vertical buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>path of convex hulls </dd></dl>

</div>
</div>
<a id="ac26ceba2a7329fa0b7c17ae586ed3b1e" name="ac26ceba2a7329fa0b7c17ae586ed3b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26ceba2a7329fa0b7c17ae586ed3b1e">&#9670;&nbsp;</a></span>bufferedConvexHull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> larcfm::PolyUtil::bufferedConvexHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>hbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vbuff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a convex hull that has been expanded by hbuff and vbuff. This extends the polygons around points, both perpendicular to the segments and directly away from vertices, approximating a round join. There may be points outside the resulting hull (near vertices) that are slightly closer to the original than the requested buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>base polygon </td></tr>
    <tr><td class="paramname">hbuff</td><td>size of horizontal buffer (approx) </td></tr>
    <tr><td class="paramname">vbuff</td><td>size of vertical buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>convex hull </dd></dl>

</div>
</div>
<a id="aabcf515d409d1048d1a9440725bf5af6" name="aabcf515d409d1048d1a9440725bf5af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcf515d409d1048d1a9440725bf5af6">&#9670;&nbsp;</a></span>calculateWxExitTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double larcfm::PolyUtil::calculateWxExitTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>incr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>entryTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Given that plan is in loss with paths at time entryTime, then this function returns the exit time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>plan </td></tr>
    <tr><td class="paramname">paths</td><td>polygon paths </td></tr>
    <tr><td class="paramname">incr</td><td>increment </td></tr>
    <tr><td class="paramname">entryTime</td><td>time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exit time </dd></dl>

</div>
</div>
<a id="a6609fd85de708619ef331228acec0433" name="a6609fd85de708619ef331228acec0433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6609fd85de708619ef331228acec0433">&#9670;&nbsp;</a></span>convexHull() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> larcfm::PolyUtil::convexHull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the convex hull of a polygon that has been expanded by (approximately) the given buffer size. This is done by adding additional points around each polygon point and taking the convex hull of them all. This assumes that the resulting hull will not include the north or south poles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>polygon </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>polygon </dd></dl>

</div>
</div>
<a id="aa3ae40f18d2f619236c80735b0b94394" name="aa3ae40f18d2f619236c80735b0b94394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ae40f18d2f619236c80735b0b94394">&#9670;&nbsp;</a></span>convexHull() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> larcfm::PolyUtil::convexHull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlarcfm_1_1_position.html">Position</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a polygon that is the convex hull of the listed points. This uses the Graham scan algorithm. For purposes of this algorithm, we only consider x, y values of positions (since all calculations are relative and no points are moved). This uses the NE-most point as the origin, to allow for our track computations (0 is north) and proceeds in a clockwise fashion This assumes that the resulting hull will not include the north or south poles (for lat lon positions) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plist</td><td>list of positions </td></tr>
    <tr><td class="paramname">bottom</td><td>lower altitude </td></tr>
    <tr><td class="paramname">top</td><td>top altitude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> </dd></dl>

</div>
</div>
<a id="a0169237cf6978d94f4db14123fd5982a" name="a0169237cf6978d94f4db14123fd5982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0169237cf6978d94f4db14123fd5982a">&#9670;&nbsp;</a></span>convexHull() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> larcfm::PolyUtil::convexHull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the convex hull of a set of polygons. This assumes that the resulting hull will not include the north or south poles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>list of polygons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>convex hull (top and bottom from max min values </dd></dl>

</div>
</div>
<a id="a83f9d1971914118c41af52351eefebc8" name="a83f9d1971914118c41af52351eefebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f9d1971914118c41af52351eefebc8">&#9670;&nbsp;</a></span>intersectsPolygon2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double larcfm::PolyUtil::intersectsPolygon2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This is a SLOW, APPROXIMATE test for 2D intersection between a moving polygon and a moving point. For more accurate (and verified) tests for this property, see polygon functions in the ACCoRD framework, specifically classes that implement the <a class="el" href="classlarcfm_1_1_detection_polygon.html">DetectionPolygon</a> interface and <a class="el" href="classlarcfm_1_1_c_d_i_i_polygon.html">CDIIPolygon</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>plan describing point-mass trajectory </td></tr>
    <tr><td class="paramname">pp</td><td>path describing polygon movement </td></tr>
    <tr><td class="paramname">B</td><td>start time to check (absolute) </td></tr>
    <tr><td class="paramname">T</td><td>end time to check (absolute) </td></tr>
    <tr><td class="paramname">incr</td><td>time increment for search (&gt; 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time of loss of separation if aircraft will intersect with the polygon between times B and T and polygon name that plan is in conflict with</dd></dl>
<p>Note: the return time will be at an interior point, and the name of the polygon </p>

</div>
</div>
<a id="afa11804b95bebc46758be968f9c1cd92" name="afa11804b95bebc46758be968f9c1cd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa11804b95bebc46758be968f9c1cd92">&#9670;&nbsp;</a></span>isPlanContained()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::PolyUtil::isPlanContained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns time of intersection if the plan is NOT free of polygons from time start to time end. This may miss intrusions of up to incr sec so it may not detect </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>plan to test </td></tr>
    <tr><td class="paramname">paths</td><td>set of polygons </td></tr>
    <tr><td class="paramname">B</td><td>start time of search </td></tr>
    <tr><td class="paramname">T</td><td>end time of search </td></tr>
    <tr><td class="paramname">incr</td><td>search increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time of intersection with a polygon if it occurs when search time interval, otherwise -1 and polygon name that plan is in conflict with</dd></dl>
<p>Returns time of intersection if the plan is NOT free of polygons from time start to time end. This may miss intrusions of up to incr sec so it may not detect </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>plan to test </td></tr>
    <tr><td class="paramname">paths</td><td>set of polygons </td></tr>
    <tr><td class="paramname">start</td><td>start time of search </td></tr>
    <tr><td class="paramname">end</td><td>end time of search </td></tr>
    <tr><td class="paramname">incr</td><td>search increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time of intersection with a polygon if it occurs when search time interval, otherwise -1 and polygon name that plan is in conflict with </dd></dl>

</div>
</div>
<a id="a07a474b60f7ca36b6882c22200d44a25" name="a07a474b60f7ca36b6882c22200d44a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a474b60f7ca36b6882c22200d44a25">&#9670;&nbsp;</a></span>pushOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_position.html">Position</a> larcfm::PolyUtil::pushOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a position that is buffer distance further away from the poly's centroid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>polygon </td></tr>
    <tr><td class="paramname">p</td><td>position </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position </dd></dl>

</div>
</div>
<a id="a8dee67c1a2e51c9eb5bf1a5079c8956f" name="a8dee67c1a2e51c9eb5bf1a5079c8956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dee67c1a2e51c9eb5bf1a5079c8956f">&#9670;&nbsp;</a></span>pushOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_position.html">Position</a> larcfm::PolyUtil::pushOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a position that is buffer distance further away from the poly's centroid at vertex i</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>polygon </td></tr>
    <tr><td class="paramname">i</td><td>index </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position </dd></dl>

</div>
</div>
<a id="ae669470dd3d47eb9425eaa4f9d4a0292" name="ae669470dd3d47eb9425eaa4f9d4a0292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae669470dd3d47eb9425eaa4f9d4a0292">&#9670;&nbsp;</a></span>reducePlanAgainstPolys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_plan.html">Plan</a> larcfm::PolyUtil::reducePlanAgainstPolys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_plan.html">Plan</a> &amp;&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>incr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leadInsPresent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>containment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attempt to minimize a given plan (by removing points) such that new segments do not intersect with any polygons. This uses the <a class="el" href="classlarcfm_1_1_poly_util.html#a83f9d1971914118c41af52351eefebc8">intersectsPolygon2D()</a> check, and so has the limitations associated with it. Use ACCoRD calls instead for better performance and/or more accuracy. Returns a new plan that is hopefully smaller than the original plan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>plan </td></tr>
    <tr><td class="paramname">paths</td><td>paths </td></tr>
    <tr><td class="paramname">incr</td><td>increment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>plan </dd></dl>
<p >fpln(" !!! reducePlanAgainstPolys: WARNING: input plan is not conflict free!!!");</p>

</div>
</div>
<a id="ac6a34367cdc8627d13052a283364b379" name="ac6a34367cdc8627d13052a283364b379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a34367cdc8627d13052a283364b379">&#9670;&nbsp;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> larcfm::PolyUtil::simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attempt to (over) approximate the given polygon with one with fewer edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>original polygon </td></tr>
    <tr><td class="paramname">buffer</td><td>approximate increase in size in any dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new larger polygon, or original polygon on failure </dd></dl>

</div>
</div>
<a id="aaa4e1f201be308652ffe954645bb1297" name="aaa4e1f201be308652ffe954645bb1297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4e1f201be308652ffe954645bb1297">&#9670;&nbsp;</a></span>simplifyToSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> larcfm::PolyUtil::simplifyToSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Attempt to over-approximate a polygons with one with the specified number of vertices. This will automatically increase the buffer by up to 30% of the original's max radius value, and either stop there or when we have no more than the desired number of vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>original polygon </td></tr>
    <tr><td class="paramname">num</td><td>desired number of vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>simple polygon </dd></dl>

</div>
</div>
<a id="a19c3baa88aaa538b89c056786ec50fee" name="a19c3baa88aaa538b89c056786ec50fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c3baa88aaa538b89c056786ec50fee">&#9670;&nbsp;</a></span>stretchOverTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> larcfm::PolyUtil::stretchOverTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_poly_path.html">PolyPath</a> &amp;&#160;</td>
          <td class="paramname"><em>pbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeAfter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Given a polypath, expand the polygons on it so they at least cover the areas that they would when over a longer time. Note: this does not work for MORPHING paths, and will convert them instead to USER_VEL_FINITE paths. Polygons are expanded to a new convex hull, meaning this will be an over-approximation. This may also not be accurate for paths with very long legs in geodetic coordinates. This may also overestimate the polygons at the start and end of each leg in the path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbase</td><td>starting path </td></tr>
    <tr><td class="paramname">timeBefore</td><td>time before the base path time to cover (relative, in seconds) </td></tr>
    <tr><td class="paramname">timeAfter</td><td>time after the base path time to cover (relative, in seconds) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new path with expanded polygons. </dd></dl>

</div>
</div>
<a id="aee9b5c8f173b120d665078e9a31aaf27" name="aee9b5c8f173b120d665078e9a31aaf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9b5c8f173b120d665078e9a31aaf27">&#9670;&nbsp;</a></span>stretchOverTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> larcfm::PolyUtil::stretchOverTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_simple_poly.html">SimplePoly</a> &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_velocity.html">Velocity</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeBefore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeAfter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stretch a polygon so that it covers (at least) what the original would as it moves over a given time range. The uses a convex hull, so will be an over-approximation. There may be inaccuracies for very long periods of time if using geodesic coordinates.</p>
<p >Example: Given a polygon W and an aircraft A with a timeAfter of 100 seconds, a conflict detection for A against the stretched polygon W' is approximately equivalent to the disjunction of conflict detections (any positive is a positive) of the set A' against the original W, where A' is the set A plus all of "echos" timeshifted up to 100 seconds into the past, modulo distortion from geodetic projections and convex hull expansions. Effectively this is saying that if the conflict detection of A vs. W' is clear, then A will be clear of W and any aircraft that precisely follow A will also be clear of W for up to 100 seconds. (If it were not clear for 100 seconds, then A would have impacted the extended W', which "arrives" 100 seconds earlier than W would.)</p>
<p >Similarly for timeBefore.</p>
<p >If A is clear of W', then it is also clear of the original W, which is a subset of W'.</p>
<p >Note this technique does not necessarily work for morphing polygons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp</td><td>base polygon </td></tr>
    <tr><td class="paramname">v</td><td>average velocity of polygon </td></tr>
    <tr><td class="paramname">timeBefore</td><td>time before stated position to cover (in sec) </td></tr>
    <tr><td class="paramname">timeAfter</td><td>time after stated position to cover (in sec) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enlarged polygon </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Modules/ACCoRD/inc/<a class="el" href="_poly_util_8h_source.html">PolyUtil.h</a></li>
<li>Modules/ACCoRD/src/PolyUtil.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
