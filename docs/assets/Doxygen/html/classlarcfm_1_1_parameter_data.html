<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICAROUS: larcfm::ParameterData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ICAROUS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelarcfm.html">larcfm</a></li><li class="navelem"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlarcfm_1_1_parameter_data-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">larcfm::ParameterData Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_parameter_data_8h_source.html">ParameterData.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data_1_1comp__order.html">comp_order</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3bfc08fe0dbe9a3fdb4da22911cf8b8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a3bfc08fe0dbe9a3fdb4da22911cf8b8d">isPreserveUnits</a> ()</td></tr>
<tr class="separator:a3bfc08fe0dbe9a3fdb4da22911cf8b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afa0b9907dc881c00ed29d49cd32fbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a7afa0b9907dc881c00ed29d49cd32fbf">setPreserveUnits</a> (bool v)</td></tr>
<tr class="separator:a7afa0b9907dc881c00ed29d49cd32fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fe626af647d688e75c6f68d154de24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a00fe626af647d688e75c6f68d154de24">isUnitCompatibility</a> ()</td></tr>
<tr class="separator:a00fe626af647d688e75c6f68d154de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39fc235232b5e8ca1fc4c37da97d318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ac39fc235232b5e8ca1fc4c37da97d318">setUnitCompatibility</a> (bool v)</td></tr>
<tr class="separator:ac39fc235232b5e8ca1fc4c37da97d318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f0725dd4a701f586675cd916ef4906"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a96f0725dd4a701f586675cd916ef4906">size</a> () const</td></tr>
<tr class="separator:a96f0725dd4a701f586675cd916ef4906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f997d0c0c3fa5670186461a96f32f2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a62f997d0c0c3fa5670186461a96f32f2">getKeyList</a> () const</td></tr>
<tr class="separator:a62f997d0c0c3fa5670186461a96f32f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb7a126195879590ebc8765bfb819c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a0bb7a126195879590ebc8765bfb819c8">getKeyListEntryOrder</a> () const</td></tr>
<tr class="separator:a0bb7a126195879590ebc8765bfb819c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb2afde922da1a06494d2831ebc4023"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a1fb2afde922da1a06494d2831ebc4023">getKeyListWithFilter</a> (<a class="el" href="classlarcfm_1_1_function.html">Function</a>&lt; const std::string &amp;, bool &gt; &amp;f) const</td></tr>
<tr class="separator:a1fb2afde922da1a06494d2831ebc4023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1ce0c3997e20b428589f3c3c66c045"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a8e1ce0c3997e20b428589f3c3c66c045">getListFull</a> () const</td></tr>
<tr class="separator:a8e1ce0c3997e20b428589f3c3c66c045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ec76c5343ff4f06f772d590201093b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ac8ec76c5343ff4f06f772d590201093b">clear</a> ()</td></tr>
<tr class="separator:ac8ec76c5343ff4f06f772d590201093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210c431444099589a41d65ccb294b66c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a210c431444099589a41d65ccb294b66c">contains</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a210c431444099589a41d65ccb294b66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfc7180e9f14d685e992d627ae17207"><td class="memItemLeft" align="right" valign="top"><a id="a5dfc7180e9f14d685e992d627ae17207" name="a5dfc7180e9f14d685e992d627ae17207"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>matchList</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:a5dfc7180e9f14d685e992d627ae17207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5104c06def2af1d2fec227994222c630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a5104c06def2af1d2fec227994222c630">copyWithPrefix</a> (const std::string &amp;prefix) const</td></tr>
<tr class="separator:a5104c06def2af1d2fec227994222c630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b6658f9ddb9b183a89f82417bda698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a58b6658f9ddb9b183a89f82417bda698">extractPrefix</a> (const std::string &amp;prefix) const</td></tr>
<tr class="separator:a58b6658f9ddb9b183a89f82417bda698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad360e2eff246c16e371ec89feb5c4563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ad360e2eff246c16e371ec89feb5c4563">removeKeysWithPrefix</a> (const std::string &amp;prefix) const</td></tr>
<tr class="separator:ad360e2eff246c16e371ec89feb5c4563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f7dad213117bf362596aa2fb62dbe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#aa90f7dad213117bf362596aa2fb62dbe">getString</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:aa90f7dad213117bf362596aa2fb62dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c6abaf3cd1946d8a265190b85cb31a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a56c6abaf3cd1946d8a265190b85cb31a">getValue</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a56c6abaf3cd1946d8a265190b85cb31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3209d23a3c68bf35172121114ff4e3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a4c3209d23a3c68bf35172121114ff4e3">getValue</a> (const std::string &amp;key, const std::string &amp;defaultUnit) const</td></tr>
<tr class="separator:a4c3209d23a3c68bf35172121114ff4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aebd202bf4146c9977395d2681cc96e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a1aebd202bf4146c9977395d2681cc96e">getUnit</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a1aebd202bf4146c9977395d2681cc96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a619ab161ebc652b4b8336025bca93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ae3a619ab161ebc652b4b8336025bca93">getBool</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:ae3a619ab161ebc652b4b8336025bca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cc873b26507d8d22d4d1709be671b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ac6cc873b26507d8d22d4d1709be671b6">getInt</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:ac6cc873b26507d8d22d4d1709be671b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2cd18c27bb63fc926ec1b3f4cada5c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#aee2cd18c27bb63fc926ec1b3f4cada5c">getLong</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:aee2cd18c27bb63fc926ec1b3f4cada5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7da8c005e05599e01a54ecd681416e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#af7da8c005e05599e01a54ecd681416e5">set</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af7da8c005e05599e01a54ecd681416e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552810104f32ba3e7a325fadb4c0f8c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a552810104f32ba3e7a325fadb4c0f8c6">set</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr class="separator:a552810104f32ba3e7a325fadb4c0f8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadc623f2ea342d7e40c8adee18c4484"><td class="memItemLeft" align="right" valign="top"><a id="adadc623f2ea342d7e40c8adee18c4484" name="adadc623f2ea342d7e40c8adee18c4484"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (const std::string &amp;key, char *value)</td></tr>
<tr class="separator:adadc623f2ea342d7e40c8adee18c4484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07df8223397f9936b9e7dc734c71366a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a07df8223397f9936b9e7dc734c71366a">set</a> (const std::string &amp;key, const char *value)</td></tr>
<tr class="separator:a07df8223397f9936b9e7dc734c71366a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b43112db9b8b221eb282b55a7aab62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a14b43112db9b8b221eb282b55a7aab62">setBool</a> (const std::string &amp;key, bool value)</td></tr>
<tr class="separator:a14b43112db9b8b221eb282b55a7aab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069a1a16d8bfa5ac40aeb350db1e65c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a069a1a16d8bfa5ac40aeb350db1e65c4">setTrue</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a069a1a16d8bfa5ac40aeb350db1e65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac564ad960ce308be10d33a5962b5fea4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ac564ad960ce308be10d33a5962b5fea4">setFalse</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ac564ad960ce308be10d33a5962b5fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51fb871e461de38bff72d6f7384d7bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ae51fb871e461de38bff72d6f7384d7bd">setInt</a> (const std::string &amp;key, int value)</td></tr>
<tr class="separator:ae51fb871e461de38bff72d6f7384d7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53482121475cacf701114de73e4189f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a53482121475cacf701114de73e4189f6">set</a> (const std::string &amp;key, double value, const std::string &amp;unit)</td></tr>
<tr class="separator:a53482121475cacf701114de73e4189f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6161ff5688a20a1490aa66ac6371eb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ab6161ff5688a20a1490aa66ac6371eb8">setInternal</a> (const std::string &amp;key, double value, const std::string &amp;units)</td></tr>
<tr class="separator:ab6161ff5688a20a1490aa66ac6371eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272fb79ec924a209fa6265fcd9d80c7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a272fb79ec924a209fa6265fcd9d80c7b">setInternal</a> (const std::string &amp;key, double value, const std::string &amp;units, int prec)</td></tr>
<tr class="separator:a272fb79ec924a209fa6265fcd9d80c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76752943162f420b049831f6dfdc2bb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a76752943162f420b049831f6dfdc2bb6">updateUnit</a> (const std::string &amp;key, const std::string &amp;unit)</td></tr>
<tr class="separator:a76752943162f420b049831f6dfdc2bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa170ce27805581613f13c333eac7feb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#aa170ce27805581613f13c333eac7feb0">updateComment</a> (const std::string &amp;key, const std::string &amp;msg)</td></tr>
<tr class="separator:aa170ce27805581613f13c333eac7feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27256865ea4c68c5efb7b3cc076f2eb7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a27256865ea4c68c5efb7b3cc076f2eb7">getComment</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a27256865ea4c68c5efb7b3cc076f2eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628052a763d12736059562ff37c36017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a628052a763d12736059562ff37c36017">setPreserveUnit</a> (const std::string &amp;key, double value, const std::string &amp;units)</td></tr>
<tr class="separator:a628052a763d12736059562ff37c36017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe8c8177bc6564bce1ccfbb634ab6b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#aafe8c8177bc6564bce1ccfbb634ab6b8">setInternalPreserveUnit</a> (const std::string &amp;key, double value, const std::string &amp;units)</td></tr>
<tr class="separator:aafe8c8177bc6564bce1ccfbb634ab6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78978b647d0efe14b06eac413f35efd1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a78978b647d0efe14b06eac413f35efd1">unrecognizedParameters</a> (std::vector&lt; std::string &gt; c) const</td></tr>
<tr class="separator:a78978b647d0efe14b06eac413f35efd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1963dfe8aa4b0c234c61e7488d80663c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a1963dfe8aa4b0c234c61e7488d80663c">validateParameters</a> (std::vector&lt; std::string &gt; c)</td></tr>
<tr class="separator:a1963dfe8aa4b0c234c61e7488d80663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1fbebf82fccb07e1477fb13f3d1190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a0c1fbebf82fccb07e1477fb13f3d1190">listCopy</a> (const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;p, const std::vector&lt; std::string &gt; &amp;plist, bool overwrite)</td></tr>
<tr class="separator:a0c1fbebf82fccb07e1477fb13f3d1190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d7b5662f576b79ec2c2bccf26da902"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a17d7b5662f576b79ec2c2bccf26da902">copy</a> (const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;p, bool overwrite)</td></tr>
<tr class="separator:a17d7b5662f576b79ec2c2bccf26da902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8b2c0b135424e0b3bec519027bf2d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#adb8b2c0b135424e0b3bec519027bf2d7">remove</a> (const std::string &amp;key)</td></tr>
<tr class="separator:adb8b2c0b135424e0b3bec519027bf2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96d40e22212c1eb82126b79ca4cec4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#aa96d40e22212c1eb82126b79ca4cec4f">removeAll</a> (const std::vector&lt; std::string &gt; &amp;key)</td></tr>
<tr class="separator:aa96d40e22212c1eb82126b79ca4cec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac1de26e7b958316c30658e250f9bb0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a6ac1de26e7b958316c30658e250f9bb0">toParameterList</a> (const std::string &amp;separator) const</td></tr>
<tr class="separator:a6ac1de26e7b958316c30658e250f9bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5179126adb6e66271752aaf21d76c47a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a5179126adb6e66271752aaf21d76c47a">parseParameterList</a> (const std::string &amp;separator, std::string line)</td></tr>
<tr class="separator:a5179126adb6e66271752aaf21d76c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052d133749c986e11edf83a37545a62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a8052d133749c986e11edf83a37545a62">isBoolean</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a8052d133749c986e11edf83a37545a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4850770972e45bcf400e6af0cedd3864"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a4850770972e45bcf400e6af0cedd3864">isNumber</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a4850770972e45bcf400e6af0cedd3864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf73287236cf2fa43b8e5c5e27ee30f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#acaf73287236cf2fa43b8e5c5e27ee30f">isString</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:acaf73287236cf2fa43b8e5c5e27ee30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff40fe579b1896791a728fc5070283c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#aff40fe579b1896791a728fc5070283c1">listToString</a> (const std::vector&lt; std::string &gt; &amp;keys) const</td></tr>
<tr class="separator:aff40fe579b1896791a728fc5070283c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f3f276c3a0e203ac8b87e8b5480f06"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ab1f3f276c3a0e203ac8b87e8b5480f06">listToString</a> (const std::vector&lt; std::string &gt; &amp;keys, const std::string &amp;separator) const</td></tr>
<tr class="separator:ab1f3f276c3a0e203ac8b87e8b5480f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675298c3872f44a360dba16d63f6cd16"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a675298c3872f44a360dba16d63f6cd16">toString</a> () const</td></tr>
<tr class="separator:a675298c3872f44a360dba16d63f6cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a95b7f2c4a33b3e1e081ac624c12ea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a97a95b7f2c4a33b3e1e081ac624c12ea">toString</a> (const std::string &amp;separator) const</td></tr>
<tr class="separator:a97a95b7f2c4a33b3e1e081ac624c12ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ff14288a4eea1d033b1e0b2c06ae2d"><td class="memItemLeft" align="right" valign="top"><a id="aa7ff14288a4eea1d033b1e0b2c06ae2d" name="aa7ff14288a4eea1d033b1e0b2c06ae2d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;pd) const</td></tr>
<tr class="separator:aa7ff14288a4eea1d033b1e0b2c06ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bba0c432df9b161c1b5ba0839b9586"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a66bba0c432df9b161c1b5ba0839b9586">diffString</a> (const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;pd) const</td></tr>
<tr class="separator:a66bba0c432df9b161c1b5ba0839b9586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9c2769e7a5cdab714462bb1a706c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#ad0c9c2769e7a5cdab714462bb1a706c0">delta</a> (const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;base) const</td></tr>
<tr class="separator:ad0c9c2769e7a5cdab714462bb1a706c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8be7edbdc0b6773ba6261936623219"><td class="memItemLeft" align="right" valign="top"><a id="ade8be7edbdc0b6773ba6261936623219" name="ade8be7edbdc0b6773ba6261936623219"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getListInteger</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:ade8be7edbdc0b6773ba6261936623219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d8edf0236c5c37df5bfb473f883ec9"><td class="memItemLeft" align="right" valign="top"><a id="a82d8edf0236c5c37df5bfb473f883ec9" name="a82d8edf0236c5c37df5bfb473f883ec9"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getListDouble</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:a82d8edf0236c5c37df5bfb473f883ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d4cc5462ad42f223711cfadd880655"><td class="memItemLeft" align="right" valign="top"><a id="af0d4cc5462ad42f223711cfadd880655" name="af0d4cc5462ad42f223711cfadd880655"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getListString</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:af0d4cc5462ad42f223711cfadd880655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24db15c05085dd5899e6220a87bd63a2"><td class="memItemLeft" align="right" valign="top"><a id="a24db15c05085dd5899e6220a87bd63a2" name="a24db15c05085dd5899e6220a87bd63a2"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getListBool</b> (const std::string &amp;key) const</td></tr>
<tr class="separator:a24db15c05085dd5899e6220a87bd63a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f26a9242c766e48a4febaefbf890d05"><td class="memItemLeft" align="right" valign="top"><a id="a8f26a9242c766e48a4febaefbf890d05" name="a8f26a9242c766e48a4febaefbf890d05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (const std::string &amp;key, const std::vector&lt; int &gt; &amp;list)</td></tr>
<tr class="separator:a8f26a9242c766e48a4febaefbf890d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae278fc077905fec0fbbbf9048f46defe"><td class="memItemLeft" align="right" valign="top"><a id="ae278fc077905fec0fbbbf9048f46defe" name="ae278fc077905fec0fbbbf9048f46defe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (const std::string &amp;key, const std::vector&lt; double &gt; &amp;list)</td></tr>
<tr class="separator:ae278fc077905fec0fbbbf9048f46defe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea98dd04a4f9917bfe9948ca567bc09"><td class="memItemLeft" align="right" valign="top"><a id="a0ea98dd04a4f9917bfe9948ca567bc09" name="a0ea98dd04a4f9917bfe9948ca567bc09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>set</b> (const std::string &amp;key, const std::vector&lt; std::string &gt; &amp;list)</td></tr>
<tr class="separator:a0ea98dd04a4f9917bfe9948ca567bc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac167a0e481867cee02c4993c86e9f1f7"><td class="memItemLeft" align="right" valign="top"><a id="ac167a0e481867cee02c4993c86e9f1f7" name="ac167a0e481867cee02c4993c86e9f1f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setListBool</b> (const std::string &amp;key, const std::vector&lt; bool &gt; &amp;list)</td></tr>
<tr class="separator:ac167a0e481867cee02c4993c86e9f1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a44bcb2bdd0762f994740082c53197bef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a44bcb2bdd0762f994740082c53197bef">make</a> ()</td></tr>
<tr class="separator:a44bcb2bdd0762f994740082c53197bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a291341614b22d6b07ae61c534594851c"><td class="memItemLeft" align="right" valign="top"><a id="a291341614b22d6b07ae61c534594851c" name="a291341614b22d6b07ae61c534594851c"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>parenPattern</b> = &quot;[()]+&quot;</td></tr>
<tr class="separator:a291341614b22d6b07ae61c534594851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a72d3c65801e84487c35c526a3c510"><td class="memItemLeft" align="right" valign="top"><a id="af0a72d3c65801e84487c35c526a3c510" name="af0a72d3c65801e84487c35c526a3c510"></a>
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>defaultEntrySeparator</b> = &quot;?&quot;</td></tr>
<tr class="separator:af0a72d3c65801e84487c35c526a3c510"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a0d4469e38e7b91fbb7516ee412cc104f"><td class="memItemLeft" align="right" valign="top"><a id="a0d4469e38e7b91fbb7516ee412cc104f" name="a0d4469e38e7b91fbb7516ee412cc104f"></a>
typedef std::map&lt; std::string, <a class="el" href="classlarcfm_1_1_parameter_entry.html">ParameterEntry</a>, <a class="el" href="structlarcfm_1_1string_case_insensitive.html">stringCaseInsensitive</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>paramtype</b></td></tr>
<tr class="separator:a0d4469e38e7b91fbb7516ee412cc104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aec86252df975dca374d02cbb108d0b9a"><td class="memItemLeft" align="right" valign="top"><a id="aec86252df975dca374d02cbb108d0b9a" name="aec86252df975dca374d02cbb108d0b9a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>longestKey</b> () const</td></tr>
<tr class="separator:aec86252df975dca374d02cbb108d0b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ac0cea5f1413b6c2d7953b8eb2cf49"><td class="memItemLeft" align="right" valign="top"><a id="ae2ac0cea5f1413b6c2d7953b8eb2cf49" name="ae2ac0cea5f1413b6c2d7953b8eb2cf49"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>longestVal</b> () const</td></tr>
<tr class="separator:ae2ac0cea5f1413b6c2d7953b8eb2cf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac3ff65250137387729b700028fc836"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a6ac3ff65250137387729b700028fc836">parse_parameter_string</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a6ac3ff65250137387729b700028fc836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef86ca2396432c49cd07dafe66a7658"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#a8ef86ca2396432c49cd07dafe66a7658">putParam</a> (const std::string &amp;key, const std::pair&lt; bool, <a class="el" href="classlarcfm_1_1_parameter_entry.html">ParameterEntry</a> &gt; &amp;entry)</td></tr>
<tr class="separator:a8ef86ca2396432c49cd07dafe66a7658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ee6f8955dd6b12e8ed1428a81c2a7c"><td class="memItemLeft" align="right" valign="top"><a id="ad1ee6f8955dd6b12e8ed1428a81c2a7c" name="ad1ee6f8955dd6b12e8ed1428a81c2a7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>putParam</b> (const std::string &amp;key, bool perform_conversion, <a class="el" href="classlarcfm_1_1_parameter_entry.html">ParameterEntry</a> &amp;entry)</td></tr>
<tr class="separator:ad1ee6f8955dd6b12e8ed1428a81c2a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d8d34366e358a6502745d31e4a8443"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="classlarcfm_1_1_parameter_entry.html">ParameterEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlarcfm_1_1_parameter_data.html#aa3d8d34366e358a6502745d31e4a8443">parse_parameter_value</a> (const std::string &amp;value)</td></tr>
<tr class="separator:aa3d8d34366e358a6502745d31e4a8443"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a02ffb93ec0c34d40e9a0735f93e10043"><td class="memItemLeft" align="right" valign="top"><a id="a02ffb93ec0c34d40e9a0735f93e10043" name="a02ffb93ec0c34d40e9a0735f93e10043"></a>
static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stringList</b> (const std::string &amp;instring)</td></tr>
<tr class="separator:a02ffb93ec0c34d40e9a0735f93e10043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd7738ed91c0d39df70beb78e9ff2e"><td class="memItemLeft" align="right" valign="top"><a id="a00cd7738ed91c0d39df70beb78e9ff2e" name="a00cd7738ed91c0d39df70beb78e9ff2e"></a>
static std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>intList</b> (const std::string &amp;instring)</td></tr>
<tr class="separator:a00cd7738ed91c0d39df70beb78e9ff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780db6e610c034b3b98c939332a35582"><td class="memItemLeft" align="right" valign="top"><a id="a780db6e610c034b3b98c939332a35582" name="a780db6e610c034b3b98c939332a35582"></a>
static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>doubleList</b> (const std::string &amp;instring)</td></tr>
<tr class="separator:a780db6e610c034b3b98c939332a35582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdd3db4795b9b92f35c75e8b15dc20d"><td class="memItemLeft" align="right" valign="top"><a id="a3bdd3db4795b9b92f35c75e8b15dc20d" name="a3bdd3db4795b9b92f35c75e8b15dc20d"></a>
static std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boolList</b> (const std::string &amp;instring)</td></tr>
<tr class="separator:a3bdd3db4795b9b92f35c75e8b15dc20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1919996ce8f2bcb76a7b679aac5a9d82"><td class="memItemLeft" align="right" valign="top"><a id="a1919996ce8f2bcb76a7b679aac5a9d82" name="a1919996ce8f2bcb76a7b679aac5a9d82"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>preserveUnits</b></td></tr>
<tr class="separator:a1919996ce8f2bcb76a7b679aac5a9d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eef625de3c9add236862b66abac174b"><td class="memItemLeft" align="right" valign="top"><a id="a9eef625de3c9add236862b66abac174b" name="a9eef625de3c9add236862b66abac174b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>unitCompatibility</b></td></tr>
<tr class="separator:a9eef625de3c9add236862b66abac174b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d301e736756d792d6dc77b7259df0fa"><td class="memItemLeft" align="right" valign="top"><a id="a6d301e736756d792d6dc77b7259df0fa" name="a6d301e736756d792d6dc77b7259df0fa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>listPatternStr</b></td></tr>
<tr class="separator:a6d301e736756d792d6dc77b7259df0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bc4a7ba3deaff654b91db7567c224e"><td class="memItemLeft" align="right" valign="top"><a id="a20bc4a7ba3deaff654b91db7567c224e" name="a20bc4a7ba3deaff654b91db7567c224e"></a>
paramtype&#160;</td><td class="memItemRight" valign="bottom"><b>parameters</b></td></tr>
<tr class="separator:a20bc4a7ba3deaff654b91db7567c224e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This class stores a database of parameters. In addition, it performs various operations parameter strings, including parsing some more complicated parameter strings into various data structures.</p>
<p >All key accesses are case insensitive, however the actual key values are stored with case information intact. Methods returning the key values (getKeyList, getListFull) will reflect the capitalization scheme used for the initial assignment to a key. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8ec76c5343ff4f06f772d590201093b" name="ac8ec76c5343ff4f06f772d590201093b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ec76c5343ff4f06f772d590201093b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes all stored parameters. </p>

</div>
</div>
<a id="a210c431444099589a41d65ccb294b66c" name="a210c431444099589a41d65ccb294b66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210c431444099589a41d65ccb294b66c">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if the parameter key was defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>parameter key to check if it is in database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if parameter is in database </dd></dl>

</div>
</div>
<a id="a17d7b5662f576b79ec2c2bccf26da902" name="a17d7b5662f576b79ec2c2bccf26da902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d7b5662f576b79ec2c2bccf26da902">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy a <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object into this object. That is, A.copy(B,true) means A &lt;&mdash; B. If either units or comments are not defined in B, then the values in A are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>source <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> </td></tr>
    <tr><td class="paramname">overwrite</td><td>if true and a key exists in both this object and p, then use p's value, otherwise keep the original value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5104c06def2af1d2fec227994222c630" name="a5104c06def2af1d2fec227994222c630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5104c06def2af1d2fec227994222c630">&#9670;&nbsp;</a></span>copyWithPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> larcfm::ParameterData::copyWithPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a copy of this <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object, with all key values being prepended with the string prefix. This is intended to create a unique <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object representing the parameters of a particular instance (of many) of an object, that can then be collected along with others into a larger <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object representing the containing object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>prefix to add to each key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> with changes </dd></dl>

</div>
</div>
<a id="ad0c9c2769e7a5cdab714462bb1a706c0" name="ad0c9c2769e7a5cdab714462bb1a706c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c9c2769e7a5cdab714462bb1a706c0">&#9670;&nbsp;</a></span>delta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> larcfm::ParameterData::delta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare this object with a base <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object and return all parameters in this object that are different from parameters in the base object, either having different values or that are not present in the base. (Parameters that are only in the base are not included.) If the objects are the same, the result will be an empty <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>"base" or "default" <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> to compare this object to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object containing all parameters that are in this object, but not in the base, or that are in both but have different values. This return may be empty. </dd></dl>

</div>
</div>
<a id="a66bba0c432df9b161c1b5ba0839b9586" name="a66bba0c432df9b161c1b5ba0839b9586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bba0c432df9b161c1b5ba0839b9586">&#9670;&nbsp;</a></span>diffString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::diffString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;&#160;</td>
          <td class="paramname"><em>pd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Compare this <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> with another. Return a string listing all differences in stored values between the two. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pd</td><td>parameter database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string listing differences, or the empty string if the contents are the same. </dd></dl>

</div>
</div>
<a id="a58b6658f9ddb9b183a89f82417bda698" name="a58b6658f9ddb9b183a89f82417bda698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b6658f9ddb9b183a89f82417bda698">&#9670;&nbsp;</a></span>extractPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> larcfm::ParameterData::extractPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a copy of this <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a>, with the string prefix removed from the beginning of all key values. If any key value in this object does not start with the given prefix, do not include it in the returned object. This is intended to filter out the parameters of a particular instance of a group of objects. The resulting <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object will include an empty string parameter if a key exactly matches the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>prefix of each key returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> with changes </dd></dl>

</div>
</div>
<a id="ae3a619ab161ebc652b4b8336025bca93" name="ae3a619ab161ebc652b4b8336025bca93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a619ab161ebc652b4b8336025bca93">&#9670;&nbsp;</a></span>getBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::getBool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the Boolean value of the given parameter key. If the key is not present, or not representation of "true", return the empty string. Parameter keys may be case-sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean representation of parameter </dd></dl>

</div>
</div>
<a id="a27256865ea4c68c5efb7b3cc076f2eb7" name="a27256865ea4c68c5efb7b3cc076f2eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27256865ea4c68c5efb7b3cc076f2eb7">&#9670;&nbsp;</a></span>getComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::getComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a parameter's comment field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comment string associated with the entry. If the entry does not exist, return the empty string. </dd></dl>

</div>
</div>
<a id="ac6cc873b26507d8d22d4d1709be671b6" name="ac6cc873b26507d8d22d4d1709be671b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cc873b26507d8d22d4d1709be671b6">&#9670;&nbsp;</a></span>getInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int larcfm::ParameterData::getInt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the integer value of the given parameter key in internal units. If no units were specified in the file, then the defaultUnit parameter is used. If the key is not present or if the value is not a numeral, then return 0. This value is an integer version of the double value (see the related getParameterValue() method). If the double value is larger than an integer, behavior is undefined. Parameter keys may be case-sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer representation of parameter </dd></dl>

</div>
</div>
<a id="a62f997d0c0c3fa5670186461a96f32f2" name="a62f997d0c0c3fa5670186461a96f32f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f997d0c0c3fa5670186461a96f32f2">&#9670;&nbsp;</a></span>getKeyList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; larcfm::ParameterData::getKeyList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns an array of parameter strings encountered, alphabetically ordered </p>

</div>
</div>
<a id="a0bb7a126195879590ebc8765bfb819c8" name="a0bb7a126195879590ebc8765bfb819c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb7a126195879590ebc8765bfb819c8">&#9670;&nbsp;</a></span>getKeyListEntryOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; larcfm::ParameterData::getKeyListEntryOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns an array of parameter strings encountered, in the order entered </p>

</div>
</div>
<a id="a1fb2afde922da1a06494d2831ebc4023" name="a1fb2afde922da1a06494d2831ebc4023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb2afde922da1a06494d2831ebc4023">&#9670;&nbsp;</a></span>getKeyListWithFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; larcfm::ParameterData::getKeyListWithFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlarcfm_1_1_function.html">Function</a>&lt; const std::string &amp;, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a list of parameter key strings encountered that satisfy the filter. Note that this will reflect the original capitalization of the keys when they were first stored.</p>
<dl class="section return"><dt>Returns</dt><dd>list of parameter key names </dd></dl>

</div>
</div>
<a id="a8e1ce0c3997e20b428589f3c3c66c045" name="a8e1ce0c3997e20b428589f3c3c66c045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1ce0c3997e20b428589f3c3c66c045">&#9670;&nbsp;</a></span>getListFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; larcfm::ParameterData::getListFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns an array of parameter definition strings encountered. </p>

</div>
</div>
<a id="aee2cd18c27bb63fc926ec1b3f4cada5c" name="aee2cd18c27bb63fc926ec1b3f4cada5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2cd18c27bb63fc926ec1b3f4cada5c">&#9670;&nbsp;</a></span>getLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long larcfm::ParameterData::getLong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the long value of the given parameter key in internal units. If no units were specified in the file, then the defaultUnit parameter is used. If the key is not present or if the value is not a numeral, then return 0. This value is an integer version of the double value (see the related getParameterValue() method). If the double value is larger than an long, behavior is undefined. <br  />
 Parameter keys may be case-sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long representation of parameter </dd></dl>

</div>
</div>
<a id="aa90f7dad213117bf362596aa2fb62dbe" name="aa90f7dad213117bf362596aa2fb62dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90f7dad213117bf362596aa2fb62dbe">&#9670;&nbsp;</a></span>getString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::getString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the string value of the given parameter key. This may be a space-delimited list. If the key is not present, return the empty string. Parameter keys may be case-sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of parameter </dd></dl>

</div>
</div>
<a id="a1aebd202bf4146c9977395d2681cc96e" name="a1aebd202bf4146c9977395d2681cc96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aebd202bf4146c9977395d2681cc96e">&#9670;&nbsp;</a></span>getUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::getUnit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the string representation of the specified unit of the given parameter key. If the key is not present or no unit was specified, return "unspecified". Parameter keys may be case-sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>units of parameter </dd></dl>

</div>
</div>
<a id="a56c6abaf3cd1946d8a265190b85cb31a" name="a56c6abaf3cd1946d8a265190b85cb31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c6abaf3cd1946d8a265190b85cb31a">&#9670;&nbsp;</a></span>getValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double larcfm::ParameterData::getValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the double-precision value of the given parameter key in internal units. If the key is not present or if the value is not a numeral, then return 0. Parameter keys may be case-sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of parameter (internal units) </dd></dl>

</div>
</div>
<a id="a4c3209d23a3c68bf35172121114ff4e3" name="a4c3209d23a3c68bf35172121114ff4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3209d23a3c68bf35172121114ff4e3">&#9670;&nbsp;</a></span>getValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double larcfm::ParameterData::getValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defaultUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the double-precision value of the given parameter key in internal units. Only in the case when units were not specified in the database, will the defaultUnit parameter be used. If the key is not present or if the value is not a numeral, then return 0. Parameter keys may be case-sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
    <tr><td class="paramname">defaultUnit</td><td>units to use if no units are in database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of parameter (internal units) </dd></dl>

</div>
</div>
<a id="a8052d133749c986e11edf83a37545a62" name="a8052d133749c986e11edf83a37545a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8052d133749c986e11edf83a37545a62">&#9670;&nbsp;</a></span>isBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::isBoolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if the stored value for key is likely a boolean </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key exists and the value is true/false/t/f, false otherwise </dd></dl>

</div>
</div>
<a id="a4850770972e45bcf400e6af0cedd3864" name="a4850770972e45bcf400e6af0cedd3864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4850770972e45bcf400e6af0cedd3864">&#9670;&nbsp;</a></span>isNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::isNumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if the stored value for key is likely a number </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key exists and the value is a parsable number </dd></dl>

</div>
</div>
<a id="a3bfc08fe0dbe9a3fdb4da22911cf8b8d" name="a3bfc08fe0dbe9a3fdb4da22911cf8b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfc08fe0dbe9a3fdb4da22911cf8b8d">&#9670;&nbsp;</a></span>isPreserveUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::isPreserveUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Will the units in the database will be updated if a subsequent set operation changes them. </p><dl class="section return"><dt>Returns</dt><dd>true, if the units in the database will be preserved when a set method is called. </dd></dl>

</div>
</div>
<a id="acaf73287236cf2fa43b8e5c5e27ee30f" name="acaf73287236cf2fa43b8e5c5e27ee30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf73287236cf2fa43b8e5c5e27ee30f">&#9670;&nbsp;</a></span>isString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::isString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if the stored value for key is likely a string (or list). Note, the <a class="el" href="classlarcfm_1_1_parameter_data.html#aa90f7dad213117bf362596aa2fb62dbe">getString()</a> method will always return a string (assuming a valid key is provided). This method returns a more narrow definition of a string, that is, something that is not a number or a boolean. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if key exists and the value is not a parse-able number </dd></dl>

</div>
</div>
<a id="a00fe626af647d688e75c6f68d154de24" name="a00fe626af647d688e75c6f68d154de24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fe626af647d688e75c6f68d154de24">&#9670;&nbsp;</a></span>isUnitCompatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::isUnitCompatibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Will set methods disallow updating a unit if the new unit is incompatible with the old unit. Meters and feet are compatible, whereas meters and kilograms are not. Most of the time, one wants the enforcement that compatible units are required, but there may be some situations where this is undesired. </p><dl class="section return"><dt>Returns</dt><dd>true, if set methods must use compatible units with the units in the database </dd></dl>

</div>
</div>
<a id="a0c1fbebf82fccb07e1477fb13f3d1190" name="a0c1fbebf82fccb07e1477fb13f3d1190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1fbebf82fccb07e1477fb13f3d1190">&#9670;&nbsp;</a></span>listCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::listCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy parameter entries from list of keys </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>database </td></tr>
    <tr><td class="paramname">plist</td><td>list of keys </td></tr>
    <tr><td class="paramname">overwrite</td><td>if a parameter key exists in both this object and p, if overwrite is true then p's value will be used, otherwise this object's value will be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff40fe579b1896791a728fc5070283c1" name="aff40fe579b1896791a728fc5070283c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff40fe579b1896791a728fc5070283c1">&#9670;&nbsp;</a></span>listToString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::listToString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a string listing of specified parameters in (original) key/value pairs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>list of parameter entries </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>multi-line string </dd></dl>

</div>
</div>
<a id="ab1f3f276c3a0e203ac8b87e8b5480f06" name="ab1f3f276c3a0e203ac8b87e8b5480f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f3f276c3a0e203ac8b87e8b5480f06">&#9670;&nbsp;</a></span>listToString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::listToString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a string listing all parameters in keys</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>list of parameter entries </td></tr>
    <tr><td class="paramname">separator</td><td>the separator (e.g., a comma) to separate each key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

</div>
</div>
<a id="a44bcb2bdd0762f994740082c53197bef" name="a44bcb2bdd0762f994740082c53197bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bcb2bdd0762f994740082c53197bef">&#9670;&nbsp;</a></span>make()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> larcfm::ParameterData::make </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A database of parameters. The database is initially empty. </p>

</div>
</div>
<a id="a6ac3ff65250137387729b700028fc836" name="a6ac3ff65250137387729b700028fc836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac3ff65250137387729b700028fc836">&#9670;&nbsp;</a></span>parse_parameter_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::parse_parameter_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Parse a string, if it is a valid parameter, then add it to the database and return true, else false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the database was updated, false otherwise. The database may not be updated because of an invalid parameter string was given, or incompatible units, etc. </dd></dl>

</div>
</div>
<a id="aa3d8d34366e358a6502745d31e4a8443" name="aa3d8d34366e358a6502745d31e4a8443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d8d34366e358a6502745d31e4a8443">&#9670;&nbsp;</a></span>parse_parameter_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="classlarcfm_1_1_parameter_entry.html">ParameterEntry</a> &gt; larcfm::ParameterData::parse_parameter_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Doesn't do error checking, string should be "trimmed." this should always return a <a class="el" href="classlarcfm_1_1_parameter_entry.html">ParameterEntry</a> </p>

</div>
</div>
<a id="a5179126adb6e66271752aaf21d76c47a" name="a5179126adb6e66271752aaf21d76c47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5179126adb6e66271752aaf21d76c47a">&#9670;&nbsp;</a></span>parseParameterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::parseParameterList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read in a set of parameters as created by <a class="el" href="classlarcfm_1_1_parameter_data.html#a6ac1de26e7b958316c30658e250f9bb0">toParameterList()</a> with the same separator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>string used to separate definitions. If blank or null, use defaultEntrySeparator instead. </td></tr>
    <tr><td class="paramname">line</td><td>String to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if string parsed successfully, false if an error occurred. If this returns false, one or more entries were not added to the database. </dd></dl>

</div>
</div>
<a id="a8ef86ca2396432c49cd07dafe66a7658" name="a8ef86ca2396432c49cd07dafe66a7658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef86ca2396432c49cd07dafe66a7658">&#9670;&nbsp;</a></span>putParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::putParam </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; bool, <a class="el" href="classlarcfm_1_1_parameter_entry.html">ParameterEntry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Put entry in parameter map </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">entry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if parameter was added successfully </dd></dl>

</div>
</div>
<a id="adb8b2c0b135424e0b3bec519027bf2d7" name="adb8b2c0b135424e0b3bec519027bf2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8b2c0b135424e0b3bec519027bf2d7">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove the given key from this database. If the key does not exist, do nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key name</td></tr>
  </table>
  </dd>
</dl>
<p>Remove the given key from this database. If the key does not exist, do nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa96d40e22212c1eb82126b79ca4cec4f" name="aa96d40e22212c1eb82126b79ca4cec4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96d40e22212c1eb82126b79ca4cec4f">&#9670;&nbsp;</a></span>removeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::removeAll </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove all keys in the list from this database, if they exist. </p>

</div>
</div>
<a id="ad360e2eff246c16e371ec89feb5c4563" name="ad360e2eff246c16e371ec89feb5c4563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad360e2eff246c16e371ec89feb5c4563">&#9670;&nbsp;</a></span>removeKeysWithPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> larcfm::ParameterData::removeKeysWithPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return a copy of this <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a>, with all keys starting with the indicated prefix removed. Only include the key values that do not start with the given prefix (if any). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>the prefix to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> without matching keys </dd></dl>

</div>
</div>
<a id="a07df8223397f9936b9e7dc734c71366a" name="a07df8223397f9936b9e7dc734c71366a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07df8223397f9936b9e7dc734c71366a">&#9670;&nbsp;</a></span>set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a parameter key with a value (both represented as strings). Examples of string values include: </p><ul>
<li>
true </li>
<li>
hello everyone! </li>
<li>
20 </li>
<li>
10 [NM] </li>
</ul>
<p >A note on this last example ('10 [NM]'). The value field may include a units descriptor in addition to the actual value. This is called the supplied units. If the supplied units are unspecified (e.g., '20'), then the units in the database for this parameter are used to interpret the value given.</p>
<p >Another note is that the string value stored is exactly what was supplied, except white space is trimmed off the beginning and end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
    <tr><td class="paramname">value</td><td>string representation of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of an invalid parameter string was given, or incompatible units, etc. </dd></dl>

</div>
</div>
<a id="a552810104f32ba3e7a325fadb4c0f8c6" name="a552810104f32ba3e7a325fadb4c0f8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552810104f32ba3e7a325fadb4c0f8c6">&#9670;&nbsp;</a></span>set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a parameter key with a value (both represented as strings). The value field may include a units descriptor in addition to the actual value, usually in a format similar to "10 [NM]", representing 10 nautical miles. </p>

</div>
</div>
<a id="a53482121475cacf701114de73e4189f6" name="a53482121475cacf701114de73e4189f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53482121475cacf701114de73e4189f6">&#9670;&nbsp;</a></span>set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a value (in the given units) with a parameter key. If the supplied units are "unspecified," then the units in the database are used to interpret the value given. How the units in the database are updated depends on the value of the <a class="el" href="classlarcfm_1_1_parameter_data.html#a7afa0b9907dc881c00ed29d49cd32fbf">setPreserveUnits()</a> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the name of the parameter </td></tr>
    <tr><td class="paramname">value</td><td>the value of the parameter in EXTERNAL units </td></tr>
    <tr><td class="paramname">units</td><td>the units of the given parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of incompatible units, etc. </dd></dl>

</div>
</div>
<a id="af7da8c005e05599e01a54ecd681416e5" name="af7da8c005e05599e01a54ecd681416e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7da8c005e05599e01a54ecd681416e5">&#9670;&nbsp;</a></span>set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Parses the given string as a parameter assignment. If successful, returns a true value and adds the parameter. Otherwise returns a false value and makes no change to the parameter database. If the supplied units are unspecified, then the units in the database are used to interpret the value given. </p>
<p >Examples of valid strings include: </p><ul>
<li>
a = true </li>
<li>
b = hello everyone! </li>
<li>
c = 10 [NM] </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the given string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of an invalid parameter string was given, or incompatible units, etc. </dd></dl>

</div>
</div>
<a id="a14b43112db9b8b221eb282b55a7aab62" name="a14b43112db9b8b221eb282b55a7aab62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b43112db9b8b221eb282b55a7aab62">&#9670;&nbsp;</a></span>setBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::setBool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a boolean value with a parameter key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
    <tr><td class="paramname">value</td><td>boolean representation of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of incompatible units, etc. </dd></dl>

</div>
</div>
<a id="ac564ad960ce308be10d33a5962b5fea4" name="ac564ad960ce308be10d33a5962b5fea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac564ad960ce308be10d33a5962b5fea4">&#9670;&nbsp;</a></span>setFalse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::setFalse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates false value with a parameter key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of incompatible units, etc. </dd></dl>

</div>
</div>
<a id="ae51fb871e461de38bff72d6f7384d7bd" name="ae51fb871e461de38bff72d6f7384d7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51fb871e461de38bff72d6f7384d7bd">&#9670;&nbsp;</a></span>setInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::setInt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates an integer value with a parameter key. Integer values always have the unit of 'unitless'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
    <tr><td class="paramname">value</td><td>integer representation of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of incompatible units, etc. </dd></dl>

</div>
</div>
<a id="ab6161ff5688a20a1490aa66ac6371eb8" name="ab6161ff5688a20a1490aa66ac6371eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6161ff5688a20a1490aa66ac6371eb8">&#9670;&nbsp;</a></span>setInternal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::setInternal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a value (in internal units) with a parameter key. How the units in the database are updated, depends on the value of the <a class="el" href="classlarcfm_1_1_parameter_data.html#a7afa0b9907dc881c00ed29d49cd32fbf">setPreserveUnits()</a> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the name of the parameter </td></tr>
    <tr><td class="paramname">value</td><td>the value of the parameter in INTERNAL units </td></tr>
    <tr><td class="paramname">units</td><td>the typical units of the value (but no conversion takes place, if "unspecified" any old value is preserved) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of incompatible units, etc. </dd></dl>

</div>
</div>
<a id="a272fb79ec924a209fa6265fcd9d80c7b" name="a272fb79ec924a209fa6265fcd9d80c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272fb79ec924a209fa6265fcd9d80c7b">&#9670;&nbsp;</a></span>setInternal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::setInternal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a value (in internal units) with a parameter key. How the units in the database are updated, depends on the value of the <a class="el" href="classlarcfm_1_1_parameter_data.html#a7afa0b9907dc881c00ed29d49cd32fbf">setPreserveUnits()</a> parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the name of the parameter </td></tr>
    <tr><td class="paramname">value</td><td>the value of the parameter in INTERNAL units </td></tr>
    <tr><td class="paramname">units</td><td>the typical units of the value (but no conversion takes place, if "unspecified" any old value is preserved) </td></tr>
    <tr><td class="paramname">prec</td><td>number of digits of precision to represent this value as a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of incompatible units, etc. </dd></dl>

</div>
</div>
<a id="aafe8c8177bc6564bce1ccfbb634ab6b8" name="aafe8c8177bc6564bce1ccfbb634ab6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe8c8177bc6564bce1ccfbb634ab6b8">&#9670;&nbsp;</a></span>setInternalPreserveUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::setInternalPreserveUnit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a value (in internal units) with a parameter key. If the parameter was already defined with a specified unit than the original unit is retained as the default unit for this parameter. If not, then the unit provided through this method becomes the default unit for this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">units</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a628052a763d12736059562ff37c36017" name="a628052a763d12736059562ff37c36017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628052a763d12736059562ff37c36017">&#9670;&nbsp;</a></span>setPreserveUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::setPreserveUnit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>units</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates a value (in the given units) with a parameter key. If the parameter was already defined with a specified unit than the original unit is retained as the default unit for this parameter. If not, then the unit provided through this method becomes the default unit for this parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">units</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7afa0b9907dc881c00ed29d49cd32fbf" name="a7afa0b9907dc881c00ed29d49cd32fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afa0b9907dc881c00ed29d49cd32fbf">&#9670;&nbsp;</a></span>setPreserveUnits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::setPreserveUnits </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Controls whether all subsequent calls to "set.." methods will update the units in the database to the units supplied through a "set.." method. The "unspecified" unit is never preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>If true, then the units in the database should be preserved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a069a1a16d8bfa5ac40aeb350db1e65c4" name="a069a1a16d8bfa5ac40aeb350db1e65c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069a1a16d8bfa5ac40aeb350db1e65c4">&#9670;&nbsp;</a></span>setTrue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::setTrue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Associates true value with a parameter key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the database was updated, false otherwise. The database may not be updated because of incompatible units, etc. </dd></dl>

</div>
</div>
<a id="ac39fc235232b5e8ca1fc4c37da97d318" name="ac39fc235232b5e8ca1fc4c37da97d318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39fc235232b5e8ca1fc4c37da97d318">&#9670;&nbsp;</a></span>setUnitCompatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void larcfm::ParameterData::setUnitCompatibility </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Controls whether set methods disallow updating a unit if the new unit is incompatible with the old unit. Meters and feet are compatible, whereas meters and kilograms are not. Most of the time, one wants the enforcement that compatible units are required, but there may be some situations where this is undesired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>true when the units in a set method must be compatible with the database. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96f0725dd4a701f586675cd916ef4906" name="a96f0725dd4a701f586675cd916ef4906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f0725dd4a701f586675cd916ef4906">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int larcfm::ParameterData::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Number of parameters in this object</p>
<dl class="section return"><dt>Returns</dt><dd>number of parameters </dd></dl>

</div>
</div>
<a id="a6ac1de26e7b958316c30658e250f9bb0" name="a6ac1de26e7b958316c30658e250f9bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac1de26e7b958316c30658e250f9bb0">&#9670;&nbsp;</a></span>toParameterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::toParameterList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return this <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> as a single line string that can subsequently be parsed by parseLine()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>A unique (to the key and value set) character string to separate each entry. If this is null or the empty string, use the defaultEntrySeparator string instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Single-line string representation of this <a class="el" href="classlarcfm_1_1_parameter_data.html">ParameterData</a> object, possibly empty, or null if the separator is a substring of any key/value entry. </dd></dl>

</div>
</div>
<a id="a675298c3872f44a360dba16d63f6cd16" name="a675298c3872f44a360dba16d63f6cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675298c3872f44a360dba16d63f6cd16">&#9670;&nbsp;</a></span>toString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a multi-line string listing all parameters and their (original string) values </p>

</div>
</div>
<a id="a97a95b7f2c4a33b3e1e081ac624c12ea" name="a97a95b7f2c4a33b3e1e081ac624c12ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a95b7f2c4a33b3e1e081ac624c12ea">&#9670;&nbsp;</a></span>toString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string larcfm::ParameterData::toString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a string listing all parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">separator</td><td>the separator (e.g., a comma) to separate each key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A separated string of all parameters</dd></dl>
<p>Returns a string listing all parameters in keys</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>list of parameter entries @parame separator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

</div>
</div>
<a id="a78978b647d0efe14b06eac413f35efd1" name="a78978b647d0efe14b06eac413f35efd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78978b647d0efe14b06eac413f35efd1">&#9670;&nbsp;</a></span>unrecognizedParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; larcfm::ParameterData::unrecognizedParameters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks the parameters against the supplied list, and returns a list of unrecognized parameters that have been read, possible empty </p>

</div>
</div>
<a id="aa170ce27805581613f13c333eac7feb0" name="aa170ce27805581613f13c333eac7feb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa170ce27805581613f13c333eac7feb0">&#9670;&nbsp;</a></span>updateComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::updateComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Updates entry's comment</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
    <tr><td class="paramname">msg</td><td>the new comment of the parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the entry does not exist, this returns false, otherwise it returns true. </dd></dl>

</div>
</div>
<a id="a76752943162f420b049831f6dfdc2bb6" name="a76752943162f420b049831f6dfdc2bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76752943162f420b049831f6dfdc2bb6">&#9670;&nbsp;</a></span>updateUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool larcfm::ParameterData::updateUnit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Updates the unit for an existing entry. This ignores the setPreservedUnits() flag. You may create a blank entry in order to preemptively store a units value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>name of parameter </td></tr>
    <tr><td class="paramname">unit</td><td>unit for this parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the unit was changed then return true, otherwise false. The unit may not be changed because it was duplicative, incompatible, not a unit, etc. </dd></dl>

</div>
</div>
<a id="a1963dfe8aa4b0c234c61e7488d80663c" name="a1963dfe8aa4b0c234c61e7488d80663c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1963dfe8aa4b0c234c61e7488d80663c">&#9670;&nbsp;</a></span>validateParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; larcfm::ParameterData::validateParameters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks the parameters against the supplied list, and returns a list of unrecognized parameters. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Modules/ACCoRD/inc/<a class="el" href="_parameter_data_8h_source.html">ParameterData.h</a></li>
<li>Modules/ACCoRD/src/ParameterData.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
