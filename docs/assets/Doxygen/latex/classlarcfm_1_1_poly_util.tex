\hypertarget{classlarcfm_1_1_poly_util}{}\doxysection{larcfm\+::Poly\+Util Class Reference}
\label{classlarcfm_1_1_poly_util}\index{larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classlarcfm_1_1_poly_util_1_1_s_i_comparator}{SIComparator}}
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_aa3ae40f18d2f619236c80735b0b94394}{convex\+Hull}} (const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} $>$ \&plist, double bottom, double top)
\item 
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a89a2d02489bb935e8b9dac524c2a36e7}\label{classlarcfm_1_1_poly_util_a89a2d02489bb935e8b9dac524c2a36e7}} 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} {\bfseries convex\+Hull} (const \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&p)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_a0169237cf6978d94f4db14123fd5982a}{convex\+Hull}} (const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} $>$ \&p)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_a6609fd85de708619ef331228acec0433}{convex\+Hull}} (const \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&p, double buffer)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_a07a474b60f7ca36b6882c22200d44a25}{push\+Out}} (\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&poly, const \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} \&p, double buffer)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_a8dee67c1a2e51c9eb5bf1a5079c8956f}{push\+Out}} (\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&poly, int i, double buffer)
\item 
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a9cbaca9d3532a92f52b8069db1a598f4}\label{classlarcfm_1_1_poly_util_a9cbaca9d3532a92f52b8069db1a598f4}} 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} {\bfseries simplify2} (\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&p, double buffer)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_ac6a34367cdc8627d13052a283364b379}{simplify}} (\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&p, double buffer)
\item 
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a8253b7a153f55b9a3b51c133f8aa7ee3}\label{classlarcfm_1_1_poly_util_a8253b7a153f55b9a3b51c133f8aa7ee3}} 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} {\bfseries simplify} (\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&p)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_aaa4e1f201be308652ffe954645bb1297}{simplify\+To\+Size}} (\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&p, int num)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_aee9b5c8f173b120d665078e9a31aaf27}{stretch\+Over\+Time}} (const \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&sp, const \mbox{\hyperlink{classlarcfm_1_1_velocity}{Velocity}} \&v, double time\+Before, double time\+After)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_a19c3baa88aaa538b89c056786ec50fee}{stretch\+Over\+Time}} (const \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \&pbase, double time\+Before, double time\+After)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_ac26ceba2a7329fa0b7c17ae586ed3b1e}{buffered\+Convex\+Hull}} (\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&p, double hbuff, double vbuff)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_afad0a34d7ac94b33c79c46a4b42de7bc}{buffered\+Convex\+Hull}} (const \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \&pbase, double hbuff, double vbuff)
\item 
static double \mbox{\hyperlink{classlarcfm_1_1_poly_util_a83f9d1971914118c41af52351eefebc8}{intersects\+Polygon2D}} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&p, \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \&pp, double B, double T, double incr)
\item 
static \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \mbox{\hyperlink{classlarcfm_1_1_poly_util_ae669470dd3d47eb9425eaa4f9d4a0292}{reduce\+Plan\+Against\+Polys}} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&plan, double gs, std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&paths, double incr, bool lead\+Ins\+Present, const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&containment)
\item 
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a93591f730a0f9a6a2fd2d9112a77288e}\label{classlarcfm_1_1_poly_util_a93591f730a0f9a6a2fd2d9112a77288e}} 
static \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} {\bfseries reduce\+Plan\+Against\+Polys} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&pln, double gs, std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&paths, double incr, bool lead\+Ins\+Present)
\item 
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a17854767b6e91ef047361c3dc09b1534}\label{classlarcfm_1_1_poly_util_a17854767b6e91ef047361c3dc09b1534}} 
static std\+::pair$<$ double, std\+::string $>$ {\bfseries is\+Plan\+In\+Conflict\+Wx} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&plan, std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&paths, double start, double end, double incr)
\item 
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a400389fb30f8cde1f1eda4425f514f10}\label{classlarcfm_1_1_poly_util_a400389fb30f8cde1f1eda4425f514f10}} 
static std\+::pair$<$ double, std\+::string $>$ {\bfseries is\+Plan\+In\+Conflict\+Wx} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&plan, std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&paths, double incr)
\item 
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a5a0b118c8dc8c2704ea1bf6b9e4f87b2}\label{classlarcfm_1_1_poly_util_a5a0b118c8dc8c2704ea1bf6b9e4f87b2}} 
static std\+::pair$<$ double, std\+::string $>$ {\bfseries is\+Plan\+In\+Conflict\+Wx} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&plan, std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&paths, double incr, double from\+Time)
\item 
static bool \mbox{\hyperlink{classlarcfm_1_1_poly_util_afa11804b95bebc46758be968f9c1cd92}{is\+Plan\+Contained}} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&plan, const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&paths, double B, double T, double incr)
\item 
static double \mbox{\hyperlink{classlarcfm_1_1_poly_util_aabcf515d409d1048d1a9440725bf5af6}{calculate\+Wx\+Exit\+Time}} (const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&plan, std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&paths, double incr, double entry\+Time)
\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_afad0a34d7ac94b33c79c46a4b42de7bc}\label{classlarcfm_1_1_poly_util_afad0a34d7ac94b33c79c46a4b42de7bc}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!bufferedConvexHull@{bufferedConvexHull}}
\index{bufferedConvexHull@{bufferedConvexHull}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{bufferedConvexHull()}{bufferedConvexHull()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} larcfm\+::\+Poly\+Util\+::buffered\+Convex\+Hull (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \&}]{pbase,  }\item[{double}]{hbuff,  }\item[{double}]{vbuff }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Return a path where polygons are replaced by convex hulls that have been expanded by hbuff and vbuff. 
\begin{DoxyParams}{Parameters}
{\em pbase} & base polygon path \\
\hline
{\em hbuff} & size of horizontal buffer (approx) \\
\hline
{\em vbuff} & size of vertical buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
path of convex hulls 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_ac26ceba2a7329fa0b7c17ae586ed3b1e}\label{classlarcfm_1_1_poly_util_ac26ceba2a7329fa0b7c17ae586ed3b1e}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!bufferedConvexHull@{bufferedConvexHull}}
\index{bufferedConvexHull@{bufferedConvexHull}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{bufferedConvexHull()}{bufferedConvexHull()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} larcfm\+::\+Poly\+Util\+::buffered\+Convex\+Hull (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&}]{p,  }\item[{double}]{hbuff,  }\item[{double}]{vbuff }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Return a convex hull that has been expanded by hbuff and vbuff. This extends the polygons around points, both perpendicular to the segments and directly away from vertices, approximating a round join. There may be points outside the resulting hull (near vertices) that are slightly closer to the original than the requested buffer. 
\begin{DoxyParams}{Parameters}
{\em p} & base polygon \\
\hline
{\em hbuff} & size of horizontal buffer (approx) \\
\hline
{\em vbuff} & size of vertical buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
convex hull 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_aabcf515d409d1048d1a9440725bf5af6}\label{classlarcfm_1_1_poly_util_aabcf515d409d1048d1a9440725bf5af6}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!calculateWxExitTime@{calculateWxExitTime}}
\index{calculateWxExitTime@{calculateWxExitTime}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{calculateWxExitTime()}{calculateWxExitTime()}}
{\footnotesize\ttfamily double larcfm\+::\+Poly\+Util\+::calculate\+Wx\+Exit\+Time (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&}]{plan,  }\item[{std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&}]{paths,  }\item[{double}]{incr,  }\item[{double}]{entry\+Time }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Given that plan is in loss with paths at time entry\+Time, then this function returns the exit time


\begin{DoxyParams}{Parameters}
{\em plan} & plan \\
\hline
{\em paths} & polygon paths \\
\hline
{\em incr} & increment \\
\hline
{\em entry\+Time} & time \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
exit time 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a6609fd85de708619ef331228acec0433}\label{classlarcfm_1_1_poly_util_a6609fd85de708619ef331228acec0433}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!convexHull@{convexHull}}
\index{convexHull@{convexHull}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{convexHull()}{convexHull()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} larcfm\+::\+Poly\+Util\+::convex\+Hull (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&}]{p,  }\item[{double}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the convex hull of a polygon that has been expanded by (approximately) the given buffer size. This is done by adding additional points around each polygon point and taking the convex hull of them all. This assumes that the resulting hull will not include the north or south poles. 
\begin{DoxyParams}{Parameters}
{\em p} & polygon \\
\hline
{\em buffer} & buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
polygon 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_aa3ae40f18d2f619236c80735b0b94394}\label{classlarcfm_1_1_poly_util_aa3ae40f18d2f619236c80735b0b94394}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!convexHull@{convexHull}}
\index{convexHull@{convexHull}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{convexHull()}{convexHull()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} larcfm\+::\+Poly\+Util\+::convex\+Hull (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} $>$ \&}]{plist,  }\item[{double}]{bottom,  }\item[{double}]{top }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Return a polygon that is the convex hull of the listed points. This uses the Graham scan algorithm. For purposes of this algorithm, we only consider x, y values of positions (since all calculations are relative and no points are moved). This uses the NE-\/most point as the origin, to allow for our track computations (0 is north) and proceeds in a clockwise fashion This assumes that the resulting hull will not include the north or south poles (for lat lon positions) 
\begin{DoxyParams}{Parameters}
{\em plist} & list of positions \\
\hline
{\em bottom} & lower altitude \\
\hline
{\em top} & top altitude \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a0169237cf6978d94f4db14123fd5982a}\label{classlarcfm_1_1_poly_util_a0169237cf6978d94f4db14123fd5982a}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!convexHull@{convexHull}}
\index{convexHull@{convexHull}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{convexHull()}{convexHull()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} larcfm\+::\+Poly\+Util\+::convex\+Hull (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} $>$ \&}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the convex hull of a set of polygons. This assumes that the resulting hull will not include the north or south poles. 
\begin{DoxyParams}{Parameters}
{\em p} & list of polygons \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
convex hull (top and bottom from max min values 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a83f9d1971914118c41af52351eefebc8}\label{classlarcfm_1_1_poly_util_a83f9d1971914118c41af52351eefebc8}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!intersectsPolygon2D@{intersectsPolygon2D}}
\index{intersectsPolygon2D@{intersectsPolygon2D}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{intersectsPolygon2D()}{intersectsPolygon2D()}}
{\footnotesize\ttfamily double larcfm\+::\+Poly\+Util\+::intersects\+Polygon2D (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&}]{p,  }\item[{\mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \&}]{pp,  }\item[{double}]{B,  }\item[{double}]{T,  }\item[{double}]{incr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is a SLOW, APPROXIMATE test for 2D intersection between a moving polygon and a moving point. For more accurate (and verified) tests for this property, see polygon functions in the ACCo\+RD framework, specifically classes that implement the \mbox{\hyperlink{classlarcfm_1_1_detection_polygon}{Detection\+Polygon}} interface and \mbox{\hyperlink{classlarcfm_1_1_c_d_i_i_polygon}{CDIIPolygon}}. 
\begin{DoxyParams}{Parameters}
{\em p} & plan describing point-\/mass trajectory \\
\hline
{\em pp} & path describing polygon movement \\
\hline
{\em B} & start time to check (absolute) \\
\hline
{\em T} & end time to check (absolute) \\
\hline
{\em incr} & time increment for search (\texorpdfstring{$>$}{>} 0) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
time of loss of separation if aircraft will intersect with the polygon between times B and T and polygon name that plan is in conflict with
\end{DoxyReturn}
Note\+: the return time will be at an interior point, and the name of the polygon \mbox{\Hypertarget{classlarcfm_1_1_poly_util_afa11804b95bebc46758be968f9c1cd92}\label{classlarcfm_1_1_poly_util_afa11804b95bebc46758be968f9c1cd92}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!isPlanContained@{isPlanContained}}
\index{isPlanContained@{isPlanContained}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{isPlanContained()}{isPlanContained()}}
{\footnotesize\ttfamily bool larcfm\+::\+Poly\+Util\+::is\+Plan\+Contained (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&}]{plan,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&}]{paths,  }\item[{double}]{B,  }\item[{double}]{T,  }\item[{double}]{incr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns time of intersection if the plan is NOT free of polygons from time start to time end. This may miss intrusions of up to incr sec so it may not detect 
\begin{DoxyParams}{Parameters}
{\em plan} & plan to test \\
\hline
{\em paths} & set of polygons \\
\hline
{\em B} & start time of search \\
\hline
{\em T} & end time of search \\
\hline
{\em incr} & search increment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
time of intersection with a polygon if it occurs when search time interval, otherwise -\/1 and polygon name that plan is in conflict with
\end{DoxyReturn}
Returns time of intersection if the plan is NOT free of polygons from time start to time end. This may miss intrusions of up to incr sec so it may not detect 
\begin{DoxyParams}{Parameters}
{\em plan} & plan to test \\
\hline
{\em paths} & set of polygons \\
\hline
{\em start} & start time of search \\
\hline
{\em end} & end time of search \\
\hline
{\em incr} & search increment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
time of intersection with a polygon if it occurs when search time interval, otherwise -\/1 and polygon name that plan is in conflict with 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a07a474b60f7ca36b6882c22200d44a25}\label{classlarcfm_1_1_poly_util_a07a474b60f7ca36b6882c22200d44a25}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!pushOut@{pushOut}}
\index{pushOut@{pushOut}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{pushOut()}{pushOut()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} larcfm\+::\+Poly\+Util\+::push\+Out (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&}]{poly,  }\item[{const \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} \&}]{p,  }\item[{double}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Return a position that is buffer distance further away from the poly\textquotesingle{}s centroid 
\begin{DoxyParams}{Parameters}
{\em poly} & polygon \\
\hline
{\em p} & position \\
\hline
{\em buffer} & buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
position 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a8dee67c1a2e51c9eb5bf1a5079c8956f}\label{classlarcfm_1_1_poly_util_a8dee67c1a2e51c9eb5bf1a5079c8956f}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!pushOut@{pushOut}}
\index{pushOut@{pushOut}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{pushOut()}{pushOut()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_position}{Position}} larcfm\+::\+Poly\+Util\+::push\+Out (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&}]{poly,  }\item[{int}]{i,  }\item[{double}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Return a position that is buffer distance further away from the poly\textquotesingle{}s centroid at vertex i


\begin{DoxyParams}{Parameters}
{\em poly} & polygon \\
\hline
{\em i} & index \\
\hline
{\em buffer} & buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
position 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_ae669470dd3d47eb9425eaa4f9d4a0292}\label{classlarcfm_1_1_poly_util_ae669470dd3d47eb9425eaa4f9d4a0292}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!reducePlanAgainstPolys@{reducePlanAgainstPolys}}
\index{reducePlanAgainstPolys@{reducePlanAgainstPolys}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{reducePlanAgainstPolys()}{reducePlanAgainstPolys()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} larcfm\+::\+Poly\+Util\+::reduce\+Plan\+Against\+Polys (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_plan}{Plan}} \&}]{plan,  }\item[{double}]{gs,  }\item[{std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&}]{paths,  }\item[{double}]{incr,  }\item[{bool}]{lead\+Ins\+Present,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} $>$ \&}]{containment }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Attempt to minimize a given plan (by removing points) such that new segments do not intersect with any polygons. This uses the \mbox{\hyperlink{classlarcfm_1_1_poly_util_a83f9d1971914118c41af52351eefebc8}{intersects\+Polygon2\+D()}} check, and so has the limitations associated with it. Use ACCo\+RD calls instead for better performance and/or more accuracy. Returns a new plan that is hopefully smaller than the original plan.


\begin{DoxyParams}{Parameters}
{\em p} & plan \\
\hline
{\em paths} & paths \\
\hline
{\em incr} & increment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
plan 
\end{DoxyReturn}
fpln(\char`\"{} !!! reduce\+Plan\+Against\+Polys\+: WARNING\+: input plan is not conflict free!!!\char`\"{});\mbox{\Hypertarget{classlarcfm_1_1_poly_util_ac6a34367cdc8627d13052a283364b379}\label{classlarcfm_1_1_poly_util_ac6a34367cdc8627d13052a283364b379}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!simplify@{simplify}}
\index{simplify@{simplify}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{simplify()}{simplify()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} larcfm\+::\+Poly\+Util\+::simplify (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&}]{p,  }\item[{double}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Attempt to (over) approximate the given polygon with one with fewer edges. 
\begin{DoxyParams}{Parameters}
{\em p} & original polygon \\
\hline
{\em buffer} & approximate increase in size in any dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new larger polygon, or original polygon on failure 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_aaa4e1f201be308652ffe954645bb1297}\label{classlarcfm_1_1_poly_util_aaa4e1f201be308652ffe954645bb1297}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!simplifyToSize@{simplifyToSize}}
\index{simplifyToSize@{simplifyToSize}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{simplifyToSize()}{simplifyToSize()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} larcfm\+::\+Poly\+Util\+::simplify\+To\+Size (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&}]{p,  }\item[{int}]{num }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Attempt to over-\/approximate a polygons with one with the specified number of vertices. This will automatically increase the buffer by up to 30\% of the original\textquotesingle{}s max radius value, and either stop there or when we have no more than the desired number of vertices. 
\begin{DoxyParams}{Parameters}
{\em p} & original polygon \\
\hline
{\em num} & desired number of vertices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
simple polygon 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_a19c3baa88aaa538b89c056786ec50fee}\label{classlarcfm_1_1_poly_util_a19c3baa88aaa538b89c056786ec50fee}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!stretchOverTime@{stretchOverTime}}
\index{stretchOverTime@{stretchOverTime}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{stretchOverTime()}{stretchOverTime()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} larcfm\+::\+Poly\+Util\+::stretch\+Over\+Time (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_poly_path}{Poly\+Path}} \&}]{pbase,  }\item[{double}]{time\+Before,  }\item[{double}]{time\+After }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Given a polypath, expand the polygons on it so they at least cover the areas that they would when over a longer time. Note\+: this does not work for MORPHING paths, and will convert them instead to USER\+\_\+\+VEL\+\_\+\+FINITE paths. Polygons are expanded to a new convex hull, meaning this will be an over-\/approximation. This may also not be accurate for paths with very long legs in geodetic coordinates. This may also overestimate the polygons at the start and end of each leg in the path. 
\begin{DoxyParams}{Parameters}
{\em pbase} & starting path \\
\hline
{\em time\+Before} & time before the base path time to cover (relative, in seconds) \\
\hline
{\em time\+After} & time after the base path time to cover (relative, in seconds) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new path with expanded polygons. 
\end{DoxyReturn}
\mbox{\Hypertarget{classlarcfm_1_1_poly_util_aee9b5c8f173b120d665078e9a31aaf27}\label{classlarcfm_1_1_poly_util_aee9b5c8f173b120d665078e9a31aaf27}} 
\index{larcfm::PolyUtil@{larcfm::PolyUtil}!stretchOverTime@{stretchOverTime}}
\index{stretchOverTime@{stretchOverTime}!larcfm::PolyUtil@{larcfm::PolyUtil}}
\doxysubsubsection{\texorpdfstring{stretchOverTime()}{stretchOverTime()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} larcfm\+::\+Poly\+Util\+::stretch\+Over\+Time (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classlarcfm_1_1_simple_poly}{Simple\+Poly}} \&}]{sp,  }\item[{const \mbox{\hyperlink{classlarcfm_1_1_velocity}{Velocity}} \&}]{v,  }\item[{double}]{time\+Before,  }\item[{double}]{time\+After }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Stretch a polygon so that it covers (at least) what the original would as it moves over a given time range. The uses a convex hull, so will be an over-\/approximation. There may be inaccuracies for very long periods of time if using geodesic coordinates.

Example\+: Given a polygon W and an aircraft A with a time\+After of 100 seconds, a conflict detection for A against the stretched polygon W\textquotesingle{} is approximately equivalent to the disjunction of conflict detections (any positive is a positive) of the set A\textquotesingle{} against the original W, where A\textquotesingle{} is the set A plus all of \char`\"{}echos\char`\"{} timeshifted up to 100 seconds into the past, modulo distortion from geodetic projections and convex hull expansions. Effectively this is saying that if the conflict detection of A vs. W\textquotesingle{} is clear, then A will be clear of W and any aircraft that precisely follow A will also be clear of W for up to 100 seconds. (If it were not clear for 100 seconds, then A would have impacted the extended W\textquotesingle{}, which \char`\"{}arrives\char`\"{} 100 seconds earlier than W would.)

Similarly for time\+Before.

If A is clear of W\textquotesingle{}, then it is also clear of the original W, which is a subset of W\textquotesingle{}.

Note this technique does not necessarily work for morphing polygons.


\begin{DoxyParams}{Parameters}
{\em sp} & base polygon \\
\hline
{\em v} & average velocity of polygon \\
\hline
{\em time\+Before} & time before stated position to cover (in sec) \\
\hline
{\em time\+After} & time after stated position to cover (in sec) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
enlarged polygon 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Modules/\+ACCo\+RD/inc/Poly\+Util.\+h\item 
Modules/\+ACCo\+RD/src/Poly\+Util.\+cpp\end{DoxyCompactItemize}
